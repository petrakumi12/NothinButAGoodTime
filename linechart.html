<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Line Chart</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
</head>
<body>
<script>
    console.log(d3);

    let margin = {top: 20, right: 20, bottom: 20, left: 20},
        width = 900 - margin.left - margin.right,
        height = 600 - margin.top - margin.bottom;

    let svg = d3.select("body")
        .append("svg")
        .attr("id", "chart")
        .attr("width", width)
        .attr("height", height)
        .style("mix-blend-mode", "hard-light")
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    let data = [];
    let datadict = {};
    let min = 100, max = -100;
    let generateTS = (id = "", startTime = 0) => {
        let tempData = Array(256);
        tempData[0] = {"x": 0, "y": 0};
        for (let i = 1; i <= 256; i++) {
            let diff = Math.random() - 0.5;
            tempData[i] = {
                "x": i + startTime,
                "y": tempData[i - 1]["y"] + diff
            };

            if (tempData[i]["y"] > max) {
                max = tempData[i]["y"]
            } else if (tempData[i]["y"] < min) {
                min = tempData[i]["y"]
            }
        }

        let tempDict = {"name": id};
        tempDict["vals"] = tempData.slice(1);
        return tempDict;
    };
    // [{"name": name, "vals": [{"x": x, "y": y}]}]

    // TODO comment for 1 TS, uncomment for array of TS
    data = [];
    for (let j = 0; j < 2500; j++) {
        // console.log("before", data)
        data.push(generateTS(j.toString(), Math.floor(Math.random() * 150000)))
        // console.log("after", data)
    }

    console.log('data here', data);

    let xmax = d3.max(data, dt => {
        return d3.max(dt.vals, datum => {
            return datum.x;
        });
    });
    let xmin = d3.min(data, dt => {
        return d3.min(dt.vals, datum => {
            return datum.x;
        });
    });
    let x0 = [xmin, xmax];
    var x = d3.scaleLinear()
        .domain(x0)
        .range([0, width]);

    max = d3.max(data, dt => {
        return d3.max(dt.vals, datum => {
            return datum.y;
        });
    });
    min = d3.min(data, dt => {
        return d3.min(dt.vals, datum => {
            return datum.y;
        });
    });
    let y0 = [min, max];
    let y = d3.scaleLinear()
        .domain(y0)
        .range([height - margin.top - margin.bottom, 0]);

    let newData = [];
    data.forEach(d => {
        let max = d3.max(d.vals, pt => pt.y);
        let min = d3.min(d.vals, pt => pt.y);
        // svg.append("g")
        //     .selectAll("line")
        //     .data([mean])
        //     .enter()
        //     .append("line")
        //     .attr("y1", d => y(d))
        //     .attr("y2", d => y(d))
        //     .attr("x1", 0)
        //     .attr("x2", 10000)
        //     .attr("stroke-width", 1)
        //     .attr("stroke", "steelblue")
        //  console.log("mean", mean)
        //  console.log("stddev", stddev)

        let datum = d.vals.map(pt => {
            return (pt["y"] - min) / (max - min)
        });
        newData.push(datum)
    });

    let idleTimeout, idleDelay = 350;

    let line = d3.line()
        .x((d) => {
            return x(d["x"])
        })
        .y((d) => {
            return y(d["y"])
        });

    let xAxis = svg.append("g")
        .attr("id", "xAxis")
        .attr("transform", "translate(0," + (height - margin.top - margin.bottom) + ")")
        .call(d3.axisBottom(x));

    let yAxis = svg.append("g")
        .attr("id", "yAxis")
        .call(d3.axisLeft(y));

    // console.log(svg)
    let paths = svg.append("g").selectAll("path")
    // .data(data.concat(newData))
        .data(data)
        .enter()
        .append("path")
        .attr("d", d => {
            return line(d.vals)
        })
        .attr("id", d => "path_" + String(d.name))
        // .style("background-color", d => {console.log("meee", d);})
        .style("stroke", "steelblue")
        .style("stroke-width", 2)
        .style("fill", "none")
        // .style("opacity", 1);
        .style("opacity", 0.1)


    //mouse moving things here

    // svg.on("mousemove", function () {
    //     var x = d3.event.pageX - margin.left;
    //     var y = d3.event.pageY - margin.top
    //     console.log('x y', x, y)
    //     // var beginning = x, end = pathLength, y;
    //     for (let i=0; i<data.length; i++){
    //         let pathEl = document.getElementById("path_"+String(i))
    //         let pos = pathEl.getPointAtLength(y);
    //         // if (pos.x > x) end = target;
    //         // else if (pos.x < x) beginning = target;
    //         if (pos.x = x) {
    //             console.log('found itTT', pathEl)//position found
    //             d3.selectAll('path')
    //                 .style("stroke-width", 2)
    //                 .style("opacity", 0.1)
    //
    //             d3.select(pathEl)
    //                 .transition()
    //                 .style("stroke-width", 3)
    //                 .style("opacity", 1)
    //             break
    //         }
    //     }
    //
    // });
    let svg_obj = document.getElementById("chart")
    svg_obj.onmousemove = function (e) {
        console.log("mousemove")
        var cur_target = e.currentTarget

        var half = (height-margin.top)/2
        var yscale = (height-margin.top-margin.bottom)/(max-min);
        var xscale = (width - margin.left)/x0[1]


        var x = (e.offsetX - margin.left)/xscale
        var y = (height - e.offsetY - margin.top - half)/yscale;

        console.log('yscale', yscale)
        console.log('xscale', xscale)

        // let height_offset = (cur_target.getBoundingClientRect().height - margin.top) / data.length;
        //also equal to step+1
        // let strip_no = Math.floor(y / height_offset)
        // console.log((cur_target.getBoundingClientRect().height - margin.top) / final_arr.length);
        console.log('x', x);
        console.log('y', y);

        for(let datum of data){
             for(let pair of datum.vals){
                if(pair['x']===Math.round(x) && pair['y']===Math.round(y)){
                    console.log('found')
                    d3.selectAll("#path_"+String(d.name))
                        .transition()
                        .style("stroke-width", 4)
                }
            }
        }

        //  for (let i=0; i<data.length; i++){
        //     let pathEl = document.getElementById("path_"+String(i))
        //     let pos = pathEl.getPointAtLength(y);
        //     // if (pos.x > x) end = target;
        //     // else if (pos.x < x) beginning = target;
        //     if (pos.x = x) {
        //         console.log('found itTT', pathEl)//position found
        //         d3.selectAll('path')
        //             .style("stroke-width", 2)
        //             .style("opacity", 0.1)
        //
        //         d3.select(pathEl)
        //             .transition()
        //             .style("stroke-width", 3)
        //             .style("opacity", 1)
        //
        //     }
        // }

    };
    ////////////////////////////////////////////


    // var pathEl = paths.node();

    // var scale = pathLength / BBox.width;
    // var offsetLeft = document.getElementById("line").offsetLeft;


    let zoom = () => {
        var selection = d3.event.selection;
        console.log(selection);
        if (!selection) {
            if (!idleTimeout) return idleTimeout = setTimeout(() => {
                idleTimeout = null
            }, idleDelay);
            x.domain(x0);
            y.domain(y0);
        } else {
            x.domain([selection[0][0], selection[1][0]].map(x.invert, x));
            y.domain([selection[1][1], selection[0][1]].map(y.invert, y));
            brushG.call(brush.move, null);
        }

        line = d3.line()
            .x((d) => {
                return x(d["x"])
            })
            .y((d) => {
                return y(d["y"])
            });
        paths.transition().duration(500)
            .attr("d", function (d) {
                return line(d.vals);
            });

        xAxis.transition().duration(500).call(d3.axisBottom(x));
        yAxis.transition().duration(500).call(d3.axisLeft(y));
    };

    let brush = d3.brush()
        .extent([[0, 0], [width, height]])
        .on("end", zoom);

    let brushG = svg.append("g")
        .attr("class", "brush")
        .call(brush)

</script>
</body>
</html>